(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{493:function(a,t,r){"use strict";r.r(t);var e=r(2),s=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),t("p",[a._v("数组中的元素可以是任意的数据类型，可以是对象，也可以是函数，也可以是数组。")]),a._v(" "),t("p",[a._v("数组属于内置对象。也属于索引-值的存储方式，索引是自然数。")]),a._v(" "),t("h3",{attrs:{id:"多维数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多维数组"}},[a._v("#")]),a._v(" 多维数组")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" arr "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("11")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("12")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("13")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("14")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\narr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("为 "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("11")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("12")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("13")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("14")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\narr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" 为 "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("11")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("12")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\narr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" 为 "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("11")]),a._v("。\n")])])]),t("h3",{attrs:{id:"对象数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象数组"}},[a._v("#")]),a._v(" 对象数组")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('const ourPets = [\n  {\n    animalType: "cat",\n    names: ["Meowzer","Fluffy","Kit-Cat"]\n  },\n  {\n    animalType: "dog",\n    names: ["Spot","Bowser","Frankie"]\n  }\n];\n数组内是对象，对象内又有数组属性。\nourPets[0].names[1];\nourPets[1].names[0];\n')])])]),t("h3",{attrs:{id:"数组复制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组复制"}},[a._v("#")]),a._v(" 数组复制")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let arr2 = arr1;\t\t// 赋的是arr1的内存地址，所以会互相影响。\n\nlet arr2 = [...arr1]; \t// 将 arr1 赋值给 arr2。arr2 会重新开辟内存地址，这样修改arr1就不会再影响arr2\nlet thatArray = Object.assign([],thisArray);\nlet arr2 = arr1.slice();\n")])])]),t("h2",{attrs:{id:"数组对象的创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组对象的创建"}},[a._v("#")]),a._v(" 数组对象的创建")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("1\nvar arr1 = []; // 创建一个空的数组\nvar arr2 = [1, 2, 3]; // 创建带初始值的数组\n\n2\nlet arr = new Array(value1, value2, value3);\nlet arr = Array(value1, value2, value3);\n如果参数为空，则表示创建一个空数组；如果参数是一个数值时，表示数组的长度；如果有多个参数时，表示数组中的元素。\n比如，\nvar arr2 = new Array(); \t// arr2 = [];\nvar arr3 = new Array(4); \t// arr3 = [null, null, null, null];\n\n3\nArray.of(value1, value2, value3);\n作用：根据参数里的内容，创建数组。\nconst arr = Array.of(1, 'abc', true);\n\nnew Array()和 Array.of()的区别在于：当参数只有一个时，前者表示数组的长度，后者表示数组中的内容。\n")])])]),t("p",[a._v("数组中可以存放任意类型的数据，不一定要全部一致，例如字符串、数字、布尔值、对象等可以混在一个数组里。")]),a._v(" "),t("p",[a._v("比如：const arr = ['qianguyihao', 28, true, { name: 'qianguyihao' }];")]),a._v(" "),t("h2",{attrs:{id:"数组长度属性-length"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组长度属性-length"}},[a._v("#")]),a._v(" 数组长度属性 length")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("length是数组的属性，不是方法。可以被修改。\n\n如果修改的 length 大于原长度，则多出部分会空出来，置为 null。\n如果修改的 length 小于原长度，则多出的元素会被删除，数组将从后面删除元素。\n")])])]),t("h2",{attrs:{id:"类型相关方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类型相关方法"}},[a._v("#")]),a._v(" 类型相关方法")]),a._v(" "),t("h3",{attrs:{id:"isarray-判断是否为数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#isarray-判断是否为数组"}},[a._v("#")]),a._v(" isArray ()判断是否为数组")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("布尔值 = Array.isArray(要被判断的数组)\n")])])]),t("h3",{attrs:{id:"数组转换为字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组转换为字符串"}},[a._v("#")]),a._v(" 数组转换为字符串")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("字符串 = 数组.toString();\n字符串 = String(数组);\t\t//上面两个方法转成的字符串会默认用,分隔数组元素。\n字符串 = 数组.join(','); \t//该方法可自定义分隔数组元素的符号。\n")])])]),t("h3",{attrs:{id:"array-from-将伪数组转换为真数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#array-from-将伪数组转换为真数组"}},[a._v("#")]),a._v(" Array.from() 将伪数组转换为真数组")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("伪数组：一个类似数组的对象。\n包含 length 属性的一连串连续自然数索引对象，比如通过getElementsByTagName()等方法获取到的节点数组；\n区别：伪数组没有数组的一般方法，比如 pop()、join() 等方法。\n\narray = Array.from(arrayLike);\n作用：将伪数组或可遍历对象转换为真数组。就可以使用数组的方法。\n")])])]),t("h2",{attrs:{id:"添加元素方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#添加元素方法"}},[a._v("#")]),a._v(" 添加元素方法")]),a._v(" "),t("h3",{attrs:{id:"push-value-数组最后插入元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#push-value-数组最后插入元素"}},[a._v("#")]),a._v(" push(value)  数组最后插入元素")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("array1.push('666','abc'); \nlet arrLength = array1.push(66,8);  \n向数组的最后面插入一个或多个元素，返回结果为新数组的长度。\n")])])]),t("h3",{attrs:{id:"unshift-value-数组最前插入元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#unshift-value-数组最前插入元素"}},[a._v("#")]),a._v(" unshift(value) 数组最前插入元素")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("array1.unshift('666','abc');\nmyArray.unshift([\"Paul\",35]);  // 插入的是一个数组，这样数组就变成二维数组\nvar arrLength = array1.unshift('666','abc');\n在数组最前面插入一个或多个元素，返回结果为新数组的长度。插入元素后，其他元素的索引会依次调整。\n")])])]),t("h3",{attrs:{id:"fill-用固定值填充数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fill-用固定值填充数组"}},[a._v("#")]),a._v(" fill() 用固定值填充数组")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("返回结果为新的数组。同时会改变原数组。\n\nArray(4).fill('f'); \t// 创建一个长度为4的空数组，然后用 'f' 来填充这个空数组\nArray1.fill('f'); \t\t// 将现有数组的每一个元素都进行填充\nArray1.fill('f', 1, 3); // 指定位置进行填充（包左不包右）\n\nlet arr1 = ['a', 'b', 'c', 'd'];\nlet arr2 = arr1.fill('f', 1, 3);\n// 结果：\narr1，arr2 ['a', 'f', 'f,' 'd']\n")])])]),t("h2",{attrs:{id:"删除元素方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#删除元素方法"}},[a._v("#")]),a._v(" 删除元素方法")]),a._v(" "),t("h3",{attrs:{id:"pop-删除数组最后一个元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pop-删除数组最后一个元素"}},[a._v("#")]),a._v(" pop() 删除数组最后一个元素")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("array1.pop();\nlet arrDeleted = array1.pop(); \n删除数组中的最后一个元素，返回结果为被删除的元素。\n")])])]),t("h3",{attrs:{id:"shift-删除数组第一个元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#shift-删除数组第一个元素"}},[a._v("#")]),a._v(" shift() 删除数组第一个元素")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("array1.shift();\nlet arrDeleted = array1.shift(); \n删除数组中的第一个元素，返回结果为被删除的元素。\n")])])]),t("h3",{attrs:{id:"splice-开始索引-删除数量-新元素-删除数组元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#splice-开始索引-删除数量-新元素-删除数组元素"}},[a._v("#")]),a._v(" splice(开始索引，删除数量，新元素)  删除数组元素")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("返回结果为被删除元素组成的新数组。\n该方法会改变原数组，会将指定元素从原数组中删除；被删除的元素会封装到一个新的数组中返回。\n\n新数组 = 原数组.splice(起始索引index, 需要删除的个数);\n新数组 = 原数组.splice(起始索引index, 需要删除的个数, 新的元素1, 新的元素2...);\n新的元素表示，删除元素之后，在被删除的索引位置向原数组中添加新的元素。\n第一个位置是0，最后一个是-1。\n\n注意：循环使用该方法时，每删除一项会自动更新数组长度及数组顺序\n\nvar result1 = arr1.splice(1); \t\t//从index为1的位置开始，删除元素\nvar result2 = arr2.splice(-2); \t\t//删除最后两个元素\nvar result3 = arr3.splice(1, 3); \t//从第index为1的位置开始删除元素,一共删除三个元素\n\nar arr5 = ['a', 'b', 'c', 'd', 'e', 'f'];\nvar result5 = arr5.splice(1, 3, '千古壹号', 'vae');//从index为1的位置开始,一共删除三个元素。之后在 index=1 的前面追加两个元素\n//结果：\narr5[\"a\",\"千古壹号\",\"vae\",\"e\",\"f\"]\nresult5[\"b\",\"c\",\"d\"]\n")])])]),t("h3",{attrs:{id:"splice-另一个用法-删除指定的第一个元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#splice-另一个用法-删除指定的第一个元素"}},[a._v("#")]),a._v(" splice()  另一个用法：删除指定的第一个元素")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const arr4 = ['a', 'b', 'c', 'd', 'c'];\narr4.splice(arr4.indexOf('c'), 1); // 删除数组中的'c'这个元素，只能删第一个。后面的自动补位。\n")])])]),t("h3",{attrs:{id:"splice-删除并添加新元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#splice-删除并添加新元素"}},[a._v("#")]),a._v(" splice() 删除并添加新元素")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const numbers = [10, 11, 12, 12, 13,15];\nnumbers.splice(3, 1, 13, 14);\t\t\t// 结果是：删除第二个12和13，并将13,14添加到删除开始的位置，也就是12的位置\n")])])]),t("h2",{attrs:{id:"提取元素组成新数组方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提取元素组成新数组方法"}},[a._v("#")]),a._v(" 提取元素组成新数组方法")]),a._v(" "),t("h3",{attrs:{id:"slice-开始位置-结束位置-从数组中提取元素为新数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#slice-开始位置-结束位置-从数组中提取元素为新数组"}},[a._v("#")]),a._v(" slice(开始位置，结束位置)  从数组中提取元素为新数组")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("返回结果为新的数组。\n该方法不会改变原数组，而是将截取到的元素封装到一个新数组中返回。\n第一个位置是0，最后一个是-1。\n\nconst result1 = arr.slice(); \t\t// 不加参数/或参数为0时，获取所有的元素。相当于数组的整体赋值\nconst result2 = arr.slice(2); \t\t// 从第二个值开始提取，直到末尾\nconst result2 = arr.slice(-2); \t\t// 倒数第二个元素\nconst result3 = arr.slice(-3,-1); \t// 提取从倒数第三个到倒数第一个之间的元素（包左不包右）\nconst result4 = arr.slice(2, 4); \t// 提取从第二个到第四个之间的元素（不包括第四个元素，包左不包右）\nconst result5 = arr.slice(4, 2); \t// 空\nconst result5 = arr.slice(2, 2); \t// 空\n\n很多会用 slice()，将伪数组转化为真数组。写法如下：\narray = Array.prototype.slice.call(arrayLike);\narray = [].slice.call(arrayLike);\nES6出了一个新的 API：（专门用来将伪数组转化成真数组），前面的 array = Array.from(arrayLike);\n")])])]),t("h2",{attrs:{id:"合并数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合并数组"}},[a._v("#")]),a._v(" 合并数组")]),a._v(" "),t("h3",{attrs:{id:"concat-连接多个数组-合并为新数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concat-连接多个数组-合并为新数组"}},[a._v("#")]),a._v(" concat() 连接多个数组，合并为新数组")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("不会改变原数组，返回结果为合并后的新数组。\n新数组 = 数组1.concat(数组2, 数组3 ...);\n\nconst arr1 = [1, 2, 3];\nconst arr2 = ['a', 'b', 'c'];\nconst arr3 = ['千古壹号', 'vae'];\n\nconst result2 = arr2.concat(arr1, arr3);\n// 结果：\nresult2 = ['a', 'b', 'c', 1, 2, 3, '千古壹号', 'vae'];\narr1, arr2, arr3没有变化\n")])])]),t("h2",{attrs:{id:"过滤数组-filter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#过滤数组-filter"}},[a._v("#")]),a._v(" 过滤数组 filter")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。\n注意： filter() 不会对空数组进行检测。\n注意： filter() 不会改变原始数组。\n\n1、去掉数组内的某些元素\nconst words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];\nconst result = words.filter(word => word.length > 6);\n\nfunction isBigEnough(element) {\n  return element >= 10;\n}\nvar filtered = [12, 5, 8, 130, 44].filter(isBigEnough);\n// filtered is [12, 130, 44]\n\n2、去掉对象数组内每个对象的其中一项属性\nthis.attrValueList是一个对象数组，\nattrValueList: [    \n   {\n     \tvalueName: \"123\",  \n     \tisEdit:true,\n   },\n   {\n     \tvalueName: \"234\",  \n     \tisEdit:true,\n   }\n   ...\n],\n\nthis.attrValueList = this.attrValueList.filter(item = >{\n    if (item.valueName != '') {\n        delete item.isEdit;\n        return true;\n    }\n});\n")])])]),t("h2",{attrs:{id:"排序数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#排序数组"}},[a._v("#")]),a._v(" 排序数组")]),a._v(" "),t("h3",{attrs:{id:"reverse-反转数组-原变"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reverse-反转数组-原变"}},[a._v("#")]),a._v(" reverse() 反转数组，原变")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("返回结果为反转后的新数组，原数组也会被反转。\nvar arr2 = arr.reverse();\n")])])]),t("h3",{attrs:{id:"赋给新数组翻转-原不变"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#赋给新数组翻转-原不变"}},[a._v("#")]),a._v(" 赋给新数组翻转，原不变")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("for (var i = 0; i < arr.length; i++) {\n\tnewArr[i] = arr[arr.length - i - 1];\n}\n")])])]),t("h3",{attrs:{id:"sort-数组排序-原变"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sort-数组排序-原变"}},[a._v("#")]),a._v(" sort() 数组排序，原变")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("无参时\n\nlet result = arr1.sort();\n默认按照Unicode 编码，从小到大进行排序。（每项元素中，按照每一位的Unicode 编码一位一位比较，所以数字11会排在2的前面）\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("带参时，自定义排序规则\n\n在 sort()方法里添加一个回调函数，来指定排序规则。浏览器根据回调函数的返回值来决定元素的排序：（重要）\n如果返回一个大于 0 的值，则元素会交换位置\n如果返回一个小于 0 的值，则元素位置不变\n如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置\n\nlet result = arr.sort(function (a, b) {\n\treturn a - b; // 升序排列；如果a>b，返回值大于0，交换，升序排列；如果a<b，返回值小于0，不交换，升序排列。\n\t// return b - a; // 降序排列\n});\n//原数组arr和返回数组result都会从小到大排列。\n\nES6的写法：\nlet result = arr.sort((a, b) => a - b);\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("一个实际的例子，对象数组：\nlet dataList = [\n    {\n        title: '品牌鞋子，高品质低价入手',\n        publishTime: 200,\n    },\n    {\n        title: '不是很贵，但是很暖',\n        publishTime: 100,\n    },\n    {\n        title: '无法拒绝的美食，跟我一起吃吃',\n        publishTime: 300,\n    },\n];\n\n// 将dataList 数组，按照 publishTime 字段，从小到大排序。（会改变原数组）\ndataList.sort((a, b) => parseInt(a.publishTime) - parseInt(b.publishTime));\n\n//排序前还要做一次 parseInt() 转换。因为，这种数据，一般是后台接口返回给前端的，数据可能是 int 类型、也可能是字符串类型，所以还是统一先做一次 partInt() 比较保险。\n")])])]),t("h2",{attrs:{id:"查找元素索引-元素是否存在"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查找元素索引-元素是否存在"}},[a._v("#")]),a._v(" 查找元素索引 / 元素是否存在")]),a._v(" "),t("h3",{attrs:{id:"indexof-和-lastindexof-获取数据的索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#indexof-和-lastindexof-获取数据的索引"}},[a._v("#")]),a._v(" indexOf() 和 lastIndexOf() 获取数据的索引")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("indexOf() 是从前向后查找元素第一次出现的位置。lastIndexOf()从后向前。\n\n这个方法的作用：可以检索一个数组中是否含有指定的元素。\n如果获取的索引值为 0，说明数组是以查询的元素为开头的。\n如果获取的索引值为-1，说明这个数组中没有指定的元素。\n\n检索时，是不仅比较值，也会比较数据类型。是严格等于===\n\nlet index = arr.indexOf('c')); //从前往后，找第一个\"c\"在哪个位置\nstr.indexOf('a', 3); // 从下标为3的位置开始查找 'a'这个元素 【重要】（起始位置从0开始）\n")])])]),t("h3",{attrs:{id:"includes-是否包含某数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#includes-是否包含某数据"}},[a._v("#")]),a._v(" includes() 是否包含某数据")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("布尔值 = arr.includes(想要查找的元素, [position]);\n参数中的 position：如果不指定，则默认为0；如果指定，则规定了检索的起始位置，从该位置往后查找。\n\n判断一个数组中是否包含指定的元素。如果是，则会返回 true；否则返回 false。\n\nconst arr = [11, 12, 13, 14, 15];\nconsole.log(arr.includes(12)); \t\t// 结果：true\nconsole.log(name.includes(20)); \t// 结果：false\nconsole.log(name.includes(11, 1)); \t// 结果：false\n")])])]),t("h3",{attrs:{id:"find-找出第一个满足「指定条件返回-true」的元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#find-找出第一个满足「指定条件返回-true」的元素"}},[a._v("#")]),a._v(" find() 找出第一个满足「指定条件返回 true」的元素")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let arr = [2, 3, 2, 5, 7, 6];\n\nlet result = arr.find((item, index) => {\n    return item > 4; //遍历数组arr，一旦发现有第一个元素大于4，就把这个元素返回\n});\n\nconsole.log(result); //结果：5\n")])])]),t("h3",{attrs:{id:"findindex-找出第一个满足「指定条件返回-true」的元素索引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#findindex-找出第一个满足「指定条件返回-true」的元素索引"}},[a._v("#")]),a._v(" findIndex() 找出第一个满足「指定条件返回 true」的元素索引")]),a._v(" "),t("p",[a._v("同上find函数，只不过返回的是元素索引。函数调用里面的内容一模一样。")]),a._v(" "),t("h2",{attrs:{id:"every-与-some"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#every-与-some"}},[a._v("#")]),a._v(" every() 与 some（）")]),a._v(" "),t("h3",{attrs:{id:"every"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#every"}},[a._v("#")]),a._v(" every()")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("对数组中每一项运行回调函数，如果都返回 true，every 就返回 true；如果有一项返回 false，则停止遍历，此方法返回 false。\n注意：every()方法的返回值是 boolean 值，参数是回调函数。\n\n实际例子1：\nconst user = [\n    {name : '李四', js : 89},\n    {name : '王五', js : 77},\n    {name : '马六', js : 55}\n];\nconst result = user.every((value) => value.js >= 60);\t//检查是否都大于等于60\n\n\n实际例子2：\nlet arr2 = [\n    { value: \"apple\" },\n    { value: \"\" },\n    { value: \"er\" }\n]\nvar res2 = arr2.every(item => {\n    return item.value !== \"\"\n})\t\t\t\t\t\t\t\t//检查是否都不为空\n\n\n实际例子3：\n[12, 5, 8, 130, 44].every(x => x >= 10); // false\n\n\n实际例子4：\nvar arr1 = ['千古', '宿敌', '南山忆', '素颜'];\nvar bool1 = arr1.every(function (element2, index, array1) {\n    return array1.length > 3 && element2.length > 1;\t//如果每项值长度大于1且数组元素大于3个，则为true。\n});\t\t// true\n\nfunction：测试每个元素的函数名；这个名称不能变，下面的参数名字可变。\n下面三个是测试函数的参数：\nelement：测试数组的值；也是默认；\nindex：测试数组值的索引；\narray：测试整个数组。\n")])])]),t("h3",{attrs:{id:"some"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#some"}},[a._v("#")]),a._v(" some()")]),a._v(" "),t("p",[a._v("数组中每一项都运行回调函数，然后只要有一个返回值满足条件，则返回true。")]),a._v(" "),t("h3",{attrs:{id:"every-和-some-的使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#every-和-some-的使用场景"}},[a._v("#")]),a._v(" every() 和 some() 的使用场景")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("every() 和 some() 这两个方法，很容易搞混。要怎么区分呢？\n\nevery()：全部真，才为真。当你需要让数组中的每一个元素都满足指定条件时，那就使用 every()。\nsome()：一个真，则为真，点到为止。数组中只要有一个元素满足指定条件时，就停止遍历。那就使用 some()。\n")])])]),t("h2",{attrs:{id:"遍历数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#遍历数组"}},[a._v("#")]),a._v(" 遍历数组")]),a._v(" "),t("h3",{attrs:{id:"foreach"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#foreach"}},[a._v("#")]),a._v(" forEach()")]),a._v(" "),t("p",[a._v("forEach() 没有返回值。")]),a._v(" "),t("p",[a._v("如果纯粹只是遍历数组，那么，可以用 forEach() 方法。但是，如果你想在遍历数组的同时，去改变数组里的元素内容，那么，最好是用 map() 方法来做，不要用 forEach()方法，避免出现一些低级错误。因为forEach()方法改变原数组的原则比较模糊。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let myArr = ['王一', '王二', '王三'];\n\nmyArr.forEach((item, index, arr) => {\n    console.log('item:' + item);\n    console.log('index:' + index);\n    console.log('arr:' + JSON.stringify(arr));\n    console.log('----------');\n});\n\n回调函数中传递三个参数：\n第一个参数，就是当前正在遍历的元素\n第二个参数，就是当前正在遍历的元素的索引\n第三个参数，就是正在遍历的数组\n--参数的名字可以改，不一定非得是item，可以改成item223\n")])])]),t("h3",{attrs:{id:"map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[a._v("#")]),a._v(" map()")]),a._v(" "),t("p",[a._v("回调函数每次执行后的返回值组合起来形成一个新数组。 不会改变原数组。")]),a._v(" "),t("p",[a._v("经常用到的是将 A 数组中某个属性的值，存储到 B 数组中。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('arr.map(function (item, index, arr) {\n    return newItem;\n});\n\n实际例子1：\nvar arr1 = [1, 3, 6, 2, 5, 6];\nvar arr2 = arr1.map(function (item, index) {\n    return item + 10; //让arr1中的每个元素加10并赋给arr2数组\n});\n\n实际例子2：\nconst arr1 = [\n    { name: \'千古壹号\', age: \'28\' },\n    { name: \'许嵩\', age: \'32\' },\n];\nconst arr2 = arr1.map((item) => item.name);\t\t// 将数组 arr1 中的 name 属性，存储到数组 arr2 中\nconst arr3 = arr1.map((item) => ({\t\t\t\t// 将数组 arr1 中的 name、age这两个属性，改一下“键”的名字，存储到 arr3中\n    myName: item.name,\n    myAge: item.age,\n}));\n结果：\narr1:[{"name":"千古壹号","age":"28"},{"name":"许嵩","age":"32"}]\narr2:["千古壹号","许嵩"]\narr3:[{"myName":"千古壹号","myAge":"28"},{"myName":"许嵩","myAge":"32"}]\n')])])]),t("h3",{attrs:{id:"map-也会改变原数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map-也会改变原数组"}},[a._v("#")]),a._v(" map()也会改变原数组")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('  const arr = [\n    {\n      name: "qianguyihao1",\n      age: 22,\n    },\n    {\n      name: "qianguyihao2",\n      age: 23,\n    },\n  ];\n\n  arr.map((item) => {\n    item.name = "haha"; // 修改 item 里的某个属性\n  });\n结果：arr数组被改变：[{"name":"haha","age":22},{"name":"haha","age":23}]\n总结：\nmap方法如果是修改整个item的值，则不会改变原数组。但如果是修改 item 里面的某个属性，那就会改变原数组。\n')])])]),t("h2",{attrs:{id:"数组条件统计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组条件统计"}},[a._v("#")]),a._v(" 数组条件统计")]),a._v(" "),t("h3",{attrs:{id:"reduce"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reduce"}},[a._v("#")]),a._v(" reduce()")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("reduce() 方法对数组中的每个元素按序执行一个由您提供的 reducer 函数\n每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。\n参数1：\ncallbackFn\n一个 “reducer” 函数，包含四个参数：\n1、previousValue：上一次调用 callbackFn 时的返回值。在第一次调用时，若指定了初始值 initialValue，其值则为 initialValue，否则为数组索引为 0 的元素。\n2、currentValue：数组中正在处理的元素。在第一次调用时，若指定了初始值 initialValue，其值则为数组索引为 0 的元素 array[0]，否则为 array[1]。\n3、currentIndex：数组中正在处理的元素的索引。若指定了初始值 initialValue，则起始索引号为 0，否则从索引 1 起始。\n4、array：用于遍历的数组。\n\n参数2：initialValue 可选\n作为第一次调用 callback 函数时参数 previousValue 的值。若指定了初始值 initialValue，则 currentValue 则将使用数组第一个元素；否则 previousValue 将使用数组第一个元素，而 currentValue 将使用数组第二个元素。\n\n返回值：使用 “reducer” 回调函数遍历整个数组后的结果。\n\n// 实际例子1：数组\nvar numbers = [65, 44, 12, 4];\nfunction getSum(total, num) {\t\t// total 为previousValue，num为currentValue。计算总数相加。\n    return total + num;\n}\nfunction myFunction(item) {\n    a = numbers.reduce(getSum);\n}\n")])])]),t("h2",{attrs:{id:"数组去重"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组去重"}},[a._v("#")]),a._v(" 数组去重")]),a._v(" "),t("h3",{attrs:{id:"splice-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#splice-方法"}},[a._v("#")]),a._v(" splice()方法")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("循环遍历，只要后面有和当前重复的，将后面的删除。\nfor(let i = 0;i < arr.length;i++)\n{\n  for(let j = i + 1;j < arr.length;j++)\n  {\n    if(arr[i] === arr[j])\n    {\n      arr.splice(j,1);\n      //如果相等，删除一个；\n      j--;\n      //这里j--是因为splice删除，后面的会自动补位，所以需要将补位的再检查一次。\n    }\n  }\n}\n")])])]),t("h3",{attrs:{id:"for循环对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#for循环对比"}},[a._v("#")]),a._v(" for循环对比")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("创建一个新数组，循环遍历，只要新数组中有老数组的值，就不用再添加了。\nvar newArr = [];\nfor(let i = 0;i < arr.length;i++)\n{\n  let bool = true;\n  for(let j = 0;j < newArr.length;j++)\n  {\n    if(arr[i] === newArr[j])\n    {\n      bool = false;\n      break; \n    } \n  }\n  if(bool)\n    newArr.push(arr[i]);\n}\n")])])]),t("h2",{attrs:{id:"求数组的最大值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#求数组的最大值"}},[a._v("#")]),a._v(" 求数组的最大值")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("apply()方法的巧妙应用：\nconst arr1 = [3, 7, 10, 8];\n\n// 无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。\nconst maxValue = Math.max.apply(Math, arr1); // 求数组 arr1 中元素的最大值\nconst minValue = Math.min.apply(Math, arr1); // 求数组 arr1 中元素的最小值\n")])])]),t("h2",{attrs:{id:"数组元素挑选分配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组元素挑选分配"}},[a._v("#")]),a._v(" 数组元素挑选分配")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("剩余参数和解构赋值配合使用\n代码举例：\nconst students = ['张三', '李四', '王五'];\nlet [s1, ...s2] = students;\t\t\t\t//数组按顺序赋给多个变量，最后一个变量不确定要赋的个数\nlet [, ...s3] = students;\t\t\t\t//s3:'李四', '王五'\n")])])]),t("h2",{attrs:{id:"arr-与-arr-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arr-与-arr-的区别"}},[a._v("#")]),a._v(" ...arr 与 arr 的区别")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("arr是一个数组，...arr是数组中的一系列值组成的连续值序列，数据类型都不同。一个是数组Array对象，一个是一系列基本数据类型。\n所以数组复制let arr2 = [...arr1]; 要用[]括起来...arr，因为括号内是基本数据类型，加上括号就变成了Array对象。\n\n所以，使用的时候，要看这里使用的是Array还是一连串基本数据类型\n")])])]),t("h2",{attrs:{id:"arguments-类数组对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#arguments-类数组对象"}},[a._v("#")]),a._v(" arguments 类数组对象")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("arguments对象包含传递给函数的每个参数。也就是全部的实参都包含在arguments对象里。它是一个类数组对象，实参以数组按顺序排在arguments对象里，也就是上面讲的伪数组，可以用上面的方法转为真实数组。\n\n比如：\ndestroyer([1, 2, 3, 1, 2, 3], 2, 3);\t\t// destroyer是一个函数。\nlet array = Array.from(arguments);\t\t\t// array: [ [ 1, 2, 3, 1, 2, 3 ], 2, 3 ]\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);