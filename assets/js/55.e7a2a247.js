(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{492:function(a,t,s){"use strict";s.r(t);var e=s(2),n=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"javascript介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript介绍"}},[a._v("#")]),a._v(" JavaScript介绍")]),a._v(" "),t("h3",{attrs:{id:"前端、解释型语言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端、解释型语言"}},[a._v("#")]),a._v(" 前端、解释型语言")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("前端是指运行在用户终端（浏览器）上，而不是服务器上；不能操作数据库。\n后台语言运行在服务器上，比如PHP，能操作数据库。\nnode.js是用JavaScript开发的后台语言。\n\t\n解释型：不需要提前整个编译成机器语言，而是翻译一行执行一行。\n")])])]),t("h3",{attrs:{id:"javascript的组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript的组成"}},[a._v("#")]),a._v(" JavaScript的组成")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("ECMAScript：\t\t\tJavaScript是语法标准，包括变量、语句、表达式、函数等语法标准。\nDOM（文档对象模型）：\t操作HTML页面上元素的API。\nBOM（浏览器对象模型）：\t操作浏览器部分功能的API。\n")])])]),t("h2",{attrs:{id:"变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变量"}},[a._v("#")]),a._v(" 变量")]),a._v(" "),t("h3",{attrs:{id:"声明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#声明"}},[a._v("#")]),a._v(" 声明")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("ES6语法之前：var name;\nES6语法之后：const name;常量\tlet age;变量\n")])])]),t("h3",{attrs:{id:"命名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#命名"}},[a._v("#")]),a._v(" 命名")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("变量名区分大小写。最佳的命名方法是驼峰法，比如let myFirstName;\n常量的常见命名做法是全部使用大写字母，单词之间用下划线分隔，比如const BLACK_COLOR;\n")])])]),t("h2",{attrs:{id:"数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[a._v("#")]),a._v(" 数据类型")]),a._v(" "),t("h3",{attrs:{id:"基本数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本数据类型"}},[a._v("#")]),a._v(" 基本数据类型")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("String 字符串\nNumber 数值\nBoolean 布尔值\nNull 空值\nUndefined 未定义\n")])])]),t("h3",{attrs:{id:"引用数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用数据类型"}},[a._v("#")]),a._v(" 引用数据类型")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("object 对象\n内置对象Function、Array、Date等都是Object类型。除了上面的五种基本类型，其余的都是Object类型。\n")])])]),t("h2",{attrs:{id:"栈内存与堆内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈内存与堆内存"}},[a._v("#")]),a._v(" 栈内存与堆内存")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("基本数据类型\nJS中，所有的变量都是保存在栈内存中的。值与值之间是独立存在，修改一个变量不会影响其他的变量。\n\n引用数据类型\n对象内容是保存到堆内存中的。每创建一个新的对象，就会在堆内存中开辟出一个新的空间；\n而对象名（变量）保存的是对象的内存地址（对象的引用），保存在栈内存当中。\n")])])]),t("h3",{attrs:{id:"引用数据类型-对象内容与变量的不同保存的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用数据类型-对象内容与变量的不同保存的问题"}},[a._v("#")]),a._v(" 引用数据类型，对象内容与变量的不同保存的问题")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var obj1 = new Object();\nobj1.name = 'smyh';\nvar obj2 = obj1;\nobj1.name = 'vae';\nconsole.log(obj1.name); // 打印结果：vae\nconsole.log(obj2.name); // 打印结果：vae\n变量obj1 和 obj2 都是引用数据类型，让 obj2 等于 obj1，两个变量保存的都是对象的地址，然后修改 obj1.name 的值之后，实际修改的是对应地址的对象，所以 obj2.name 的值也发生了改变。\n所以，这句var obj1 = new Object();实际上是分为两部分。先是new Object()，新创建一个对象，然后把内容地址赋值给obj1。\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("如何不影响地把对象复制？\nvar obj1 = new Object();\nobj1.name = 'smyh';\nvar obj3 = Object.assign({}, obj1); \t//通过 Object.assign() 来复制对象\n这样，修改obj1就不会影响obj3的内容，因为obj3有单独的对象内容保存在堆内存中。\n")])])]),t("h2",{attrs:{id:"switch-case"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#switch-case"}},[a._v("#")]),a._v(" switch case")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("switch的原理：遇到符合的case就进入，然后结束的条件是：遇到 break 就结束或者执行到程序的末尾就结束。\n\nswitch 语句的结束与否和 default 的顺序无关，但是建议放到最后。\n\n实际例子：\nvar number = 5;\nswitch (number) {\n    default:\n        console.log('我是defaul语句');\n    case 2:\n        console.log('第二个呵呵:' + number);\n    case 3:\n        console.log('第三个呵呵:' + number);\n        break;\n    case 4:\n        console.log('第四个呵呵:' + number);\n        break;\n}\n这段代码的输出结果是：\n我是defaul语句\n第二个呵呵:5\n第三个呵呵:5\n//理由是default和case2都没有break，所以发生case穿透，没有结束，即使后面的case2不匹配，也会继续执行后面的语句直到break。\n")])])]),t("h2",{attrs:{id:"从其他js文件导入函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从其他js文件导入函数"}},[a._v("#")]),a._v(" 从其他js文件导入函数")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("import * as myMathModule from \"./math_functions.js\";\n上面的 import 语句会创建一个叫作 myMathModule 的对象。 这只是一个变量名，可以随便命名。 \n对象包含 math_functions.js 文件里的所有导出，可以像访问对象的属性那样访问里面的函数。 \n下面是使用导入的 add 和 subtract 函数的例子：\n\nimport { add, subtract } from './math_functions.js';\n// 导入一部分函数\n\nmyMathModule.add(2,3);\nmyMathModule.subtract(5,3);\n")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);