(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{491:function(t,a,e){"use strict";e.r(a);var n=e(2),s=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"对象简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象简介"}},[t._v("#")]),t._v(" 对象简介")]),t._v(" "),a("p",[t._v("对象是一组无序的属性和方法的集合。对象的作用是封装信息。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("保存一个值，用变量；保存一组类型一致的值，用数组。\n\n但是如果要保存一组具有相关性但是数据类型又五花八门的数据时，用数组就不合适。比如，var arr = ['王二', 35, '男', '180'];\n这时，就需要用对象保存：\nvar person = {};\nperson.name = '王二';\nperson.age = 35;\nperson.sex = '男';\n")])])]),a("h3",{attrs:{id:"对象的内存保存-传值传址"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的内存保存-传值传址"}},[t._v("#")]),t._v(" 对象的内存保存/传值传址")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("对象的值是保存在堆内存中的，而对象的引用（即变量）是保存在栈内存中的。如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响。\n\n实际例子：\nvar obj1 = new Object();\nvar obj2 = obj1;\t\t//obj1 和 obj2 指向了同一个堆内存空间\nobj1.name = 'vae';\t\t//结果：obj2.name 的值也发生了改变\n\n如何不影响地把对象复制？\nvar obj3 = Object.assign({}, obj1); \t//通过 Object.assign() 来复制对象\n")])])]),a("h3",{attrs:{id:"object-assign复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-assign复制"}},[t._v("#")]),t._v(" Object.assign复制")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let obj = { name: "", sex: "", age: "" };\nlet obj1 = { name: "bob", sex: "male" };\nlet obj2 = { name: "", age: "22" };\nObject.assign(obj, obj1, obj2);\nconsole.log(obj);\t\t// 结果是：{name: "", sex: "male", age: "22"}\n// 也就是，会把同名的属性复制给第一个对象，但是后面的会覆盖掉前面的。\n')])])]),a("h2",{attrs:{id:"对象的分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的分类"}},[t._v("#")]),t._v(" 对象的分类")]),t._v(" "),a("h3",{attrs:{id:"内置对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内置对象"}},[t._v("#")]),t._v(" 内置对象")]),t._v(" "),a("p",[t._v("由ES标准中定义的对象，比如：Object、Math、Date、String、Array、Number、Boolean、Function等。（这里的String和Number是对象名，不是数据类型string，number）")]),t._v(" "),a("h3",{attrs:{id:"宿主对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宿主对象"}},[t._v("#")]),t._v(" 宿主对象")]),t._v(" "),a("p",[t._v("由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象。")]),t._v(" "),a("p",[t._v("比如 BOM DOM。比如console、document。")]),t._v(" "),a("h3",{attrs:{id:"自定义对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义对象"}},[t._v("#")]),t._v(" 自定义对象")]),t._v(" "),a("p",[t._v("由开发人员自己创建的对象，通过 new 关键字创建出来的对象实例。")]),t._v(" "),a("h2",{attrs:{id:"对象的创建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的创建"}},[t._v("#")]),t._v(" 对象的创建")]),t._v(" "),a("h3",{attrs:{id:"方式一-var-obj"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方式一-var-obj"}},[t._v("#")]),t._v(" 方式一：var obj = {};")]),t._v(" "),a("p",[t._v("也就是创建对象名时就把内容也建好。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('const obj2 = {\n    name: "千古壹号",\n    age: 26,\n    test: {\t\t\t\t\t\t\t// 还可以存放一个嵌套的对象\n        id: 123,\n        tel: 180\n    }    \n    sayName: function() {\t\t\t//增加一个方法。以后可以通过obj2.sayName()的方式调用这个方法\n        console.log(this.name);\n    }\n};\n')])])]),a("h3",{attrs:{id:"方式二-new-object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方式二-new-object"}},[t._v("#")]),t._v(" 方式二：new Object()")]),t._v(" "),a("p",[t._v("本质上是先 new Object()创建对象名，后面再添加内容。但是创建出的对象都是Object这种类型，无法自定义。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function createPerson(name, age, gender) {   \n    var obj = new Object();\t\t\t//创建一个新的对象\n    obj.name = name;\t\t\t\t//向对象中添加属性\n    obj.age = age;\n    obj.gender = gender;\n    obj.sayName = function () {\n        alert(this.name);\n    };    \n    return obj;\t\t\t\t\t\t//将新的对象返回\n}\n\nvar obj2 = createPerson('猪八戒', 28, '男');\nvar obj3 = createPerson('白骨精', 16, '女');\n")])])]),a("h3",{attrs:{id:"方式三-构造函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方式三-构造函数"}},[t._v("#")]),t._v(" 方式三：构造函数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Student(name) //自定义Student对象的构造函数\n{\n\tthis.name = name; //this指的是当前对象实例\n\tthis.sayHi = function () {\n    \tconsole.log(this.name + '厉害了');\n\t};\n}\nvar stu1 = new Student('smyh');\t\t//利用构造函数自定义Student对象，如果没有前面的Student构造函数，Student关键字就是无意义的\n")])])]),a("h4",{attrs:{id:"与普通函数的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与普通函数的区别"}},[t._v("#")]),t._v(" 与普通函数的区别")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("- 构造函数习惯上首字母大写\n- 普通函数是直接调用，而构造函数需要使用 new 关键字来调用。比如new Student('smyh');\n- this的指向也不同：\n\t1.以函数的形式调用时，this 永远都是 window。比如fun();相当于window.fun();\n\t2.以方法的形式调用时，this 是调用方法的那个对象\n\t3.以构造函数的形式调用时，this 是新创建的实例对象\n")])])]),a("h4",{attrs:{id:"new一个构造函数的流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new一个构造函数的流程"}},[t._v("#")]),t._v(" new一个构造函数的流程")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. 开辟内存空间，在内存中创建一个新的空对象（也就是对象实例）\n2. 让this指向这个新的空对象\n3. 执行构造函数的代码，给新对象添加属性和方法\n4. 返回这个新对象（所以构造函数里面不需要 return）。但是new调用时的返回值，显式返回函数或者对象，比如下面，返回的就不是新生成的对象。\n\t// return function f(){};\n    // return {};\n")])])]),a("h3",{attrs:{id:"静态成员和实例成员"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态成员和实例成员"}},[t._v("#")]),t._v(" 静态成员和实例成员")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("JavaScript 的构造函数中可以添加一些属性、方法。\n静态成员：在构造函数本身上添加的成员称为静态成员，只能由构造函数本身来访问。\n实例成员：在构造函数内部的this上添加称为实例成员，只能由实例化的对象来访问。\n\n实际例子：\nfunction Person(name,age) {\n\tthis.name = name;\t\t\t\t//这里的name/age属性，sayHi方法都是实际成员\n\tthis.age = age;\n\tthis.sayHi = function(){\n\t\tconsole.log('Hello...');\n\t} \n\tPerson.hobby = 'Irunning';\n  \tPerson.climb = function(){\n    \tconsole.log('Climbing...')\n    } \n}\nvar p1 = new Person('Lucy',29);\n\n结果：\np1.name;\np1.sayHi();\nPerson.climb();\nPerson.hobby;\t\t//以上是正确的，静态成员只能由构造函数本身来访问；实例成员只能由实例化的对象来访问\np1.climb();\t\t\t//报错\nPerson.sayHi();\t\t//报错\n")])])]),a("h2",{attrs:{id:"类-实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类-实例"}},[t._v("#")]),t._v(" 类&实例")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("将一个构造函数称为一个类。\n使用同一个构造函数创建的对象，我们称为一类对象，也将这些对象，称为该类的实例。\nObject类是所有类的祖先。因为Student类是这么来的，var Student = new Object();\n")])])]),a("h3",{attrs:{id:"类的创建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的创建"}},[t._v("#")]),t._v(" 类的创建")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Rectangle {\n    // constructor 构造函数\n    constructor(height, width) {\n        this.height = height;\n        this.width = width;\n    }\n    // Getter 外传属性\n    get area() {\n        return this.calcArea()\n    }\n    // setter 传进并修改属性\n    set writer(updatedAuthor) {\n    \tthis._width = updatedAuthor;\n  \t}\n    // Method 普通方法\n    calcArea() {\n        return this.height * this.width;\n    }\n    // static 静态方法。\n    static distance(a, b) {\n        const dx = a.x - b.x;\n        const dy = a.y - b.y;\n        return Math.hypot(dx, dy);\n        // 通过类名调用静态方法，不能通过一个类实例调用静态方法。\n        // p1.distance;错误\t\tRectangle.distance(p1, p2);正确\n    }\n}\n")])])]),a("h2",{attrs:{id:"对象-实例-的基本操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象-实例-的基本操作"}},[t._v("#")]),t._v(" 对象（实例）的基本操作")]),t._v(" "),a("h3",{attrs:{id:"获取对象属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取对象属性"}},[t._v("#")]),t._v(" 获取对象属性")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("特殊属性名：\n比如说，123、my这种非字符串或有空格的属性名，用 对象['属性名'] = 属性值;\nobj.123 = 789\t\t//错误\nobj['123'] = 789;\t//正确\n\n\n属性名是在一个变量里：\nlet zhuName = 'name';\t//变量zhuName的内容必须要和对象obj的属性名一致，也就是obj要有一个属性名为name的属性。\nobj[zhuName] = 789;\t\t//变量名不加引号\n\n\n如果获取对象中没有定义的属性，不会报错而是返回undefined。\n")])])]),a("h3",{attrs:{id:"检查对象是否有该属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#检查对象是否有该属性"}},[t._v("#")]),t._v(" 检查对象是否有该属性")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("我们平时使用的对象不一定是自己创建的，可能是从接口获取的，这个时候，in 运算符可以派上用场。\n\nconsole.log('name' in obj);\t\t\t//'属性名' in 对象;\t\t\t\nif (obj.name) {\t\t\t\t\t\t//另一种写法：如果对象obj中有name属性，我就。。。\n}\n")])])]),a("h3",{attrs:{id:"for-in-对象循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for-in-对象循环"}},[t._v("#")]),t._v(" for in  对象循环")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("对象（实例）中有几个属性，循环体就会执行几次。每次执行时，会将对象中的每个属性的 属性名 赋值给变量。\nfor (var key in obj) \t\t\t\t\t//key不是关键字，而是可变的变量名\n{\n    console.log('属性名:' + key); \t\t// 这里的 key 是：对象属性的键（也就是属性名）\n    console.log('属性值:' + obj[key]); // 这里的 obj[key] 是：对象属性的值（也就是属性值）\n}\n\n嵌套对象的for in遍历：\nconst usersObj = {\t\t//嵌套对象\n  Alan: {\n    online: false\n  },\n  Jeff: {\n    online: true\n  }\n}\n//使用usersObj[user]循环第一层所有对象\nfor (let user in usersObj) {\n    if (usersObj[user].online === true) {\n      。。。\n    }\n}\n")])])]),a("h3",{attrs:{id:"移除对象属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移除对象属性"}},[t._v("#")]),t._v(" 移除对象属性")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("delete 对象.属性;\n")])])]),a("h2",{attrs:{id:"object-defineproperty方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty方法"}},[t._v("#")]),t._v(" Object.defineProperty方法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\nconst object1 = {};\nObject.defineProperty(object1, 'property1', {\n  value: 42,\n  writable: false,\t\t// 该属性能否被重新赋值。\n  enumerable: true, \t// 该属性是否可以在 for...in 循环和 Object.keys() 中被枚举。\n  configurable: false \t// 该属性是否可以被删除\n  \n  // 当property1属性被读取时，get函数就会被调用，返回值就是property1属性值\n  get: function() {\n      console.log('属性被读取，get被调用');\n      return property1;\n  },\n  \n  // 当property1属性被修改时，set函数就会被调用，且会收到修改的值\n  set: function(value) {\n  \t  console.log('属性被修改，set被调用');\n      property1 = value;\n  }\n});\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);