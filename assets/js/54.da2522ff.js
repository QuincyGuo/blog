(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{489:function(t,a,n){"use strict";n.r(a);var e=n(2),s=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"函数也是对象的一种"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数也是对象的一种"}},[t._v("#")]),t._v(" 函数也是对象的一种")]),t._v(" "),a("p",[t._v("函数也属于对象，对象类型是function。")]),t._v(" "),a("h2",{attrs:{id:"函数的定义-声明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数的定义-声明"}},[t._v("#")]),t._v(" 函数的定义/声明")]),t._v(" "),a("h3",{attrs:{id:"方式一-function关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方式一-function关键字"}},[t._v("#")]),t._v(" 方式一：function关键字")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function fun1(a,b)\n{\n  return a+b;\n}\n")])])]),a("h3",{attrs:{id:"方式二-函数表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方式二-函数表达式"}},[t._v("#")]),t._v(" 方式二：函数表达式")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var 变量名 = function(a,b)\n{\n  语句....\n}\n所谓的“函数表达式”，其实就是将匿名函数（无名函数）赋给一个变量。这个变量里保存的是一个函数，而不是一个值。\n")])])]),a("p",[t._v("其实，函数是一个function对象，他是保存在堆内存中的，而函数名是一个变量，保存在栈内存中。所以，这两种方式的表达方式并没有本质上的区别，函数名和这个函数表达式（变量）都是名称和内容分别保存。")]),t._v(" "),a("h2",{attrs:{id:"函数的调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数的调用"}},[t._v("#")]),t._v(" 函数的调用")]),t._v(" "),a("h3",{attrs:{id:"方式1-普通函数的调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方式1-普通函数的调用"}},[t._v("#")]),t._v(" 方式1：普通函数的调用")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("代码举例：\nfunction fn1() {\n\tconsole.log('我是函数体里面的内容1');\n}\nfn1(); \t\t// 调用函数\nfn1.call(); // 调用函数\n")])])]),a("h3",{attrs:{id:"方式2-通过对象的方法来调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方式2-通过对象的方法来调用"}},[t._v("#")]),t._v(" 方式2：通过对象的方法来调用")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var obj = {\n\ta: 'qianguyihao',\n\tfn2: function() {\n\t\tconsole.log('千古壹号，永不止步!');\n\t},\n};\nobj.fn2(); // 调用函数\n")])])]),a("h3",{attrs:{id:"方式3-立即执行函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方式3-立即执行函数"}},[t._v("#")]),t._v(" 方式3：立即执行函数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("(function() {\n\tconsole.log('我是立即执行函数');\t//立即执行函数在定义后，会自动调用。\n})();\n立即执行函数往往只会执行一次。为什么呢？因为没有变量保存它，执行完了之后，就找不到它了。\n")])])]),a("h2",{attrs:{id:"参数相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参数相关"}},[t._v("#")]),t._v(" 参数相关")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("- 函数的实参可以是任意的数据类型。所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查。\n- 如果实参的数量少于形参的数量，多余的形参会被定义为 undefined。表达式的运行结果为 NaN。\n")])])]),a("h2",{attrs:{id:"return-相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#return-相关"}},[t._v("#")]),t._v(" return 相关")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("- 如果return语句后不跟任何值，就相当于返回一个undefined\n- 如果函数中不写return，则也会返回undefined\n- 返回值可以是任意的数据类型，可以是对象，也可以是函数，也可以是一个表达式（return a<b; 返回的是布尔值）。\n- return 只能返回一个值。如果用逗号隔开多个值，则以最后一个为准。\n")])])]),a("h2",{attrs:{id:"fn-和-fn-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fn-和-fn-的区别"}},[t._v("#")]),t._v(" fn() 和 fn 的区别")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("fn()")]),t._v("：调用函数。调用之后，还获取了函数的返回值。")]),t._v(" "),a("li",[a("code",[t._v("fn")]),t._v("：函数对象。相当于直接获取了整个函数对象。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function name2(a,b)\n{\n\treturn a + b;\n}\nconsole.log(name2);\nconsole.log(name2(a,b));\n上面两句代码执行的结果是不同的。第一句结果是，将整个函数体显示出来；第二句是显示函数返回结果。\n")])])]),a("h2",{attrs:{id:"函数作为返回值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数作为返回值"}},[t._v("#")]),t._v(" 函数作为返回值")]),t._v(" "),a("p",[t._v("函数作为返回值，一般用于回调函数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('以函数防抖代码为例：\nfunction debounce(fn, delay) {\n    var timer; // 定义一个timer\n    return function () {\t// 这里是将函数作为返回值\n      clearTimeout(timer); \n      timer = setTimeout(function () {fn()}, delay); \n    };\n}\n函数调用：\ninput.oninput = debounce(function () {\n    console.log("ajax发请求");\n}, 1000);\n// 执行完后，input.oninput的内容会是一个函数，也就是，每次oninput都会执行这段函数代码。\n\n但如果，写成子函数定义使用，等于只是调用了一次debounce，给input.oninput没留下什么，并不意味着每次触发input.oninput就调用debounce函数\nfunction debounce(fn, delay) {\n    var timer; // 定义一个timer\n    function aa() {\t// 这里是将函数作为返回值\n      clearTimeout(timer); \n      timer = setTimeout(function () {fn()}, delay); \n    };\n    aa();\n}\n')])])])])}),[],!1,null,null,null);a.default=s.exports}}]);